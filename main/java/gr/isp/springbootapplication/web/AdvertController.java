package gr.isp.springbootapplication.web;

import gr.isp.springbootapplication.entity.Advert;
import gr.isp.springbootapplication.entity.SessionUser;
import gr.isp.springbootapplication.entity.User;
import gr.isp.springbootapplication.repository.AdvertRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Controller
public class AdvertController {

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private AdvertRepository advertRepository;

    @GetMapping("/user/myAdverts")
    public String myAdverts(Model model) {

        Iterable<Advert> adverts = advertRepository.findByUserId(getSessionUser().getId());
        List<Advert> advertArray = new ArrayList<Advert>();
        for (Advert ad: adverts) {
            advertArray.add(ad);
        }
        model.addAttribute("advertArray",advertArray);

        return "myAdverts";
    }

    @GetMapping(path = "/user/postAd")
    public String postAd() {
        return "postAdvert";
    }

    @PostMapping(path = "/user/postAdding") // Map ONLY POST Requests
    public String addNewAdvert(RedirectAttributes redir,
                               @RequestParam String action,
                               @RequestParam String title,
                               @RequestParam String body,
                               @RequestParam String salary,
                               @RequestParam String industry) {
        // @RequestParam means it is a parameter from the GET or POST request

        boolean titleError;
        boolean bodyError;
        boolean salaryError = false;
        Integer salaryInt = 0;

        try {
            if (!(salary.isEmpty())) {
                salaryInt = Integer.parseInt(salary);
            }
        } catch (NumberFormatException | NullPointerException nfe) {
            salaryError = true;
            redir.addFlashAttribute("salaryError", salaryError);
        }

        if (!(title.isEmpty() || body.isEmpty() || salaryError)) {
            Advert ad = new Advert();
            ad.setTitle(title);
            ad.setBody(body);
            if (industry.isEmpty()) industry = "No Industry";
            ad.setIndustry(industry);
            if (salaryInt == null) salaryInt = 0;
            ad.setSalary(salaryInt);
            if (action.equals("Post")){
                ad.setStatus("Visible");
            }
            else if (action.equals("Save")){
                ad.setStatus("Draft");
            }

            //LocalDateTime.now() creates an object that is too long for SQL, so we have to cut the last parts (the nanoseconds) in order to not insert corrupt date to the DB
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime nowTooLong = LocalDateTime.now();
            String nowStr = nowTooLong.format(formatter);
            LocalDateTime timePosted = LocalDateTime.parse(nowStr, formatter);
            ad.setTimePosted(timePosted);

            User u = new User(getSessionUser().getId());
            ad.setUser(u);

            advertRepository.save(ad);
            return "redirect:/";
        } else {
            if (title.isEmpty()) {
                titleError = true;
                redir.addFlashAttribute("titleError", titleError);
            }
            if (body.isEmpty()) {
                bodyError = true;
                redir.addFlashAttribute("bodyError", bodyError);
            }

            redir.addFlashAttribute("title", title);
            redir.addFlashAttribute("body", body);
            redir.addFlashAttribute("industry", industry);
            redir.addFlashAttribute("salary", salary);

            return "redirect:/user/postAd";
        }
    }

    @GetMapping(path = "/user/allPosts")
    public @ResponseBody
    Iterable<Advert> getAllUsers() {
        // This returns a JSON or XML with the users
        return advertRepository.findByUserId(getSessionUser().getId());
    }

    @PostMapping(path = "/user/postEditing") // Map ONLY POST Requests
    public String editAdvert(RedirectAttributes redir,
                             @RequestParam String action,
                             @RequestParam String id,
                             @RequestParam String title,
                             @RequestParam String body,
                             @RequestParam String salary,
                             @RequestParam String industry,
                             @RequestParam String userId,
                             @RequestParam String timePostedStr,
                             @RequestParam String status

    ) {
        // @RequestParam means it is a parameter from the GET or POST request
        //timePosted is not validated for now
        long userIdLong = 0;
        if (!(userId.isEmpty())) {
            userIdLong = Long.parseLong(userId);
        }

        long idLong = 0;
        if (!(id.isEmpty())) {
            idLong = Long.parseLong(id);
        }
        Advert advertBefore = advertRepository.findFirstById(idLong);

        if (advertBefore.getUser().getId() == getSessionUser().getId() && advertBefore.getUser().getId() == userIdLong) {

            if (action.equals("Update")) {

                boolean titleError = false;
                boolean bodyError = false;
                boolean salaryError = false;
                Integer salaryInt = 0;

                try {
                    if (!(salary.isEmpty())) {
                        salaryInt = Integer.parseInt(salary);
                    }
                } catch (NumberFormatException | NullPointerException nfe) {
                    salaryError = true;
                    redir.addFlashAttribute("salaryError", salaryError);
                }

                if (!(title.isEmpty() || body.isEmpty() || salaryError)) {
                    Advert advertAfter = new Advert();
                    advertAfter.setId(idLong);
                    advertAfter.setTitle(title);
                    advertAfter.setBody(body);
                    advertAfter.setIndustry(industry);
                    if (salaryInt == null) salaryInt = 0;
                    advertAfter.setSalary(salaryInt);
                    advertAfter.setStatus(status);
                    User u = new User(userIdLong);
                    advertAfter.setUser(u);
                    // if it goes from invisible to visible or from draft to visible, the time posted needs to be updated (just a guess, needs confirmation from client)
                    if ((advertBefore.getStatus().equals("Invisible") || advertBefore.getStatus().equals("Draft"))  && status.equals("Visible")) {
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                        LocalDateTime nowTooLong = LocalDateTime.now();
                        String nowStr = nowTooLong.format(formatter);
                        LocalDateTime timePosted = LocalDateTime.parse(nowStr, formatter);
                        advertAfter.setTimePosted(timePosted);
                    }
                    //if status is not changed or goes, from visible to invisible, we don't have to worry about timePosted so just take the string taken from the form
                    else {
                        //the timeposted comes as a string from the front-end, we need to convert it, string contains a T so
                        //the formatter differs a bit from the one used for posting
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
                        LocalDateTime timePosted = LocalDateTime.parse(timePostedStr, formatter);
                        advertAfter.setTimePosted(timePosted);
                    }
                    advertRepository.save(advertAfter);
                    return "redirect:/user/myAdverts";
                } else {
                    if (title.isEmpty()) {
                        titleError = true;
                        redir.addFlashAttribute("titleError", titleError);
                    }
                    if (body.isEmpty()) {
                        bodyError = true;
                        redir.addFlashAttribute("bodyError", bodyError);
                    }

                    redir.addFlashAttribute("title", title);
                    redir.addFlashAttribute("body", body);
                    redir.addFlashAttribute("industry", industry);
                    redir.addFlashAttribute("salary", salary);

                    return "redirect:/user/myAdverts";
                }
            }
        else if (action.equals("Delete")) {
            advertRepository.deleteById(idLong);
                return "redirect:/user/myAdverts";
            }
        }
        else {
            return "redirect:/user/myAdverts";
        }
        // no idea why i need this return and the compiler insists that i put a return here
        return "redirect:/user/myAdverts";
    }



    private SessionUser getSessionUser (){
        SecurityContext securityContext = SecurityContextHolder.getContext();
        SessionUser user = null;
        if( SecurityContextHolder.getContext().getAuthentication() != null && SecurityContextHolder.getContext().getAuthentication().isAuthenticated() && !(SecurityContextHolder.getContext().getAuthentication() instanceof AnonymousAuthenticationToken) ){
            user = (SessionUser) securityContext.getAuthentication().getPrincipal();
        }
        return user;
    }

}
